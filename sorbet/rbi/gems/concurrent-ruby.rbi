# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/concurrent-ruby/all/concurrent-ruby.rbi
#
# concurrent-ruby-1.0.5
module Concurrent
  def abort_transaction; end
  def atomically; end
  def call_dataflow(method, executor, *inputs, &block); end
  def dataflow!(*inputs, &block); end
  def dataflow(*inputs, &block); end
  def dataflow_with!(executor, *inputs, &block); end
  def dataflow_with(executor, *inputs, &block); end
  def leave_transaction; end
  def monotonic_time; end
  def self.abort_transaction; end
  def self.atomically; end
  def self.call_dataflow(method, executor, *inputs, &block); end
  def self.create_simple_logger(level = nil, output = nil); end
  def self.create_stdlib_logger(level = nil, output = nil); end
  def self.dataflow!(*inputs, &block); end
  def self.dataflow(*inputs, &block); end
  def self.dataflow_with!(executor, *inputs, &block); end
  def self.dataflow_with(executor, *inputs, &block); end
  def self.disable_at_exit_handlers!; end
  def self.executor(executor_identifier); end
  def self.global_fast_executor; end
  def self.global_immediate_executor; end
  def self.global_io_executor; end
  def self.global_logger; end
  def self.global_logger=(value); end
  def self.global_timer_set; end
  def self.leave_transaction; end
  def self.monotonic_time; end
  def self.new_fast_executor(opts = nil); end
  def self.new_io_executor(opts = nil); end
  def self.physical_processor_count; end
  def self.processor_count; end
  def self.processor_counter; end
  def self.use_simple_logger(level = nil, output = nil); end
  def self.use_stdlib_logger(level = nil, output = nil); end
  extend Concurrent::Concern::Logging
  extend Concurrent::Utility::EngineDetector
  extend Concurrent::Utility::NativeExtensionLoader
end
class Concurrent::Error < StandardError
end
class Concurrent::ConfigurationError < Concurrent::Error
end
class Concurrent::CancelledOperationError < Concurrent::Error
end
class Concurrent::LifecycleError < Concurrent::Error
end
class Concurrent::ImmutabilityError < Concurrent::Error
end
class Concurrent::IllegalOperationError < Concurrent::Error
end
class Concurrent::InitializationError < Concurrent::Error
end
class Concurrent::MaxRestartFrequencyError < Concurrent::Error
end
class Concurrent::MultipleAssignmentError < Concurrent::Error
  def initialize(message = nil, inspection_data = nil); end
  def inspect; end
  def inspection_data; end
end
class Concurrent::RejectedExecutionError < Concurrent::Error
end
class Concurrent::ResourceLimitError < Concurrent::Error
end
class Concurrent::TimeoutError < Concurrent::Error
end
class Concurrent::MultipleErrors < Concurrent::Error
  def errors; end
  def initialize(errors, message = nil); end
end
module Concurrent::Utility
end
module Concurrent::Utility::EngineDetector
  def on_cruby?; end
  def on_jruby?; end
  def on_jruby_9000?; end
  def on_linux?; end
  def on_osx?; end
  def on_rbx?; end
  def on_truffle?; end
  def on_windows?; end
  def ruby_engine; end
  def ruby_version(comparison, major, minor, patch, version = nil); end
end
module Concurrent::Synchronization
end
class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier; end
  def initialize; end
  def self.attr_volatile(*names); end
end
module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?; end
  def c_extensions_loaded?; end
  def java_extensions_loaded?; end
  def load_native_extensions; end
  def set_c_extensions_loaded; end
  def set_java_extensions_loaded; end
end
module Concurrent::Synchronization::MriAttrVolatile
  def full_memory_barrier; end
  def self.included(base); end
end
module Concurrent::Synchronization::MriAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end
class Concurrent::Synchronization::MriObject < Concurrent::Synchronization::AbstractObject
  def initialize; end
  extend Concurrent::Synchronization::MriAttrVolatile::ClassMethods
  include Concurrent::Synchronization::MriAttrVolatile
end
module Concurrent::Synchronization::RbxAttrVolatile
  def full_memory_barrier; end
  def self.included(base); end
end
module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end
class Concurrent::Synchronization::RbxObject < Concurrent::Synchronization::AbstractObject
  def initialize; end
  extend Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  include Concurrent::Synchronization::RbxAttrVolatile
end
module Concurrent::Synchronization::TruffleAttrVolatile
  def full_memory_barrier; end
  def self.included(base); end
end
module Concurrent::Synchronization::TruffleAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end
class Concurrent::Synchronization::TruffleObject < Concurrent::Synchronization::AbstractObject
  def initialize; end
  extend Concurrent::Synchronization::TruffleAttrVolatile::ClassMethods
  include Concurrent::Synchronization::TruffleAttrVolatile
end
class Concurrent::Synchronization::Object < Concurrent::Synchronization::MriObject
  def initialize; end
  def initialize_volatile_with_cas; end
  def self.attr_atomic(*names); end
  def self.define_initialize_volatile_with_cas; end
  def self.ensure_safe_initialization_when_final_fields_are_present; end
  def self.safe_initialization!; end
  def self.safe_initialization?; end
  def self.volatile_cas_fields(inherited = nil); end
end
class Concurrent::Synchronization::AbstractLockableObject < Concurrent::Synchronization::Object
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = nil); end
  def ns_wait_until(timeout = nil, &condition); end
  def synchronize; end
end
class Concurrent::Synchronization::MriLockableObject < Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast; end
  def ns_signal; end
end
class Concurrent::Synchronization::MriMutexLockableObject < Concurrent::Synchronization::MriLockableObject
  def initialize(*defaults); end
  def ns_wait(timeout = nil); end
  def self.new(*args, &block); end
  def synchronize; end
end
class Concurrent::Synchronization::MriMonitorLockableObject < Concurrent::Synchronization::MriLockableObject
  def initialize(*defaults); end
  def ns_wait(timeout = nil); end
  def self.new(*args, &block); end
  def synchronize; end
end
class Concurrent::Synchronization::RbxLockableObject < Concurrent::Synchronization::AbstractLockableObject
  def initialize(*defaults); end
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = nil); end
  def self.new(*args, &block); end
  def synchronize(&block); end
end
class Concurrent::Synchronization::TruffleLockableObject < Concurrent::Synchronization::AbstractLockableObject
  def new(*arg0); end
end
class Concurrent::Synchronization::LockableObject < Concurrent::Synchronization::MriMutexLockableObject
  def new_condition; end
end
class Concurrent::Synchronization::Condition < Concurrent::Synchronization::LockableObject
  def broadcast; end
  def initialize(lock); end
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = nil); end
  def ns_wait_until(timeout = nil, &condition); end
  def self.new(*args, &block); end
  def self.private_new(*args, &block); end
  def signal; end
  def wait(timeout = nil); end
  def wait_until(timeout = nil, &condition); end
end
class Concurrent::Synchronization::Lock < Concurrent::Synchronization::LockableObject
  def broadcast; end
  def ns_broadcast; end
  def ns_signal; end
  def ns_wait(timeout = nil); end
  def ns_wait_until(timeout = nil, &condition); end
  def signal; end
  def synchronize; end
  def wait(timeout = nil); end
  def wait_until(timeout = nil, &condition); end
end
class Concurrent::Event < Concurrent::Synchronization::LockableObject
  def initialize; end
  def ns_initialize; end
  def ns_set; end
  def reset; end
  def set; end
  def set?; end
  def try?; end
  def wait(timeout = nil); end
end
module Concurrent::Concern
end
module Concurrent::Concern::Dereferenceable
  def apply_deref_options(value); end
  def deref; end
  def ns_set_deref_options(opts); end
  def set_deref_options(opts = nil); end
  def value; end
  def value=(value); end
end
module Concurrent::Concern::Obligation
  def compare_and_set_state(next_state, *expected_current); end
  def complete?; end
  def event; end
  def exception(*args); end
  def fulfilled?; end
  def get_arguments_from(opts = nil); end
  def if_state(*expected_states); end
  def incomplete?; end
  def init_obligation; end
  def no_error!(timeout = nil); end
  def ns_check_state?(expected); end
  def ns_set_state(value); end
  def pending?; end
  def realized?; end
  def reason; end
  def rejected?; end
  def set_state(success, value, reason); end
  def state; end
  def state=(value); end
  def unscheduled?; end
  def value!(timeout = nil); end
  def value(timeout = nil); end
  def wait!(timeout = nil); end
  def wait(timeout = nil); end
  include Concurrent::Concern::Dereferenceable
end
module Concurrent::Concern::Logging
  def log(level, progname, message = nil, &block); end
  include Logger::Severity
end
module Concurrent::ExecutorService
  def <<(task); end
  def can_overflow?; end
  def post(*args, &task); end
  def serialized?; end
  include Concurrent::Concern::Logging
end
class Concurrent::AtExitImplementation < Concurrent::Synchronization::LockableObject
  def add(handler_id = nil, &handler); end
  def delete(handler_id); end
  def enabled=(value); end
  def enabled?; end
  def handler?(handler_id); end
  def handlers; end
  def initialize(*args); end
  def install; end
  def ns_initialize(enabled = nil); end
  def run; end
  def runner; end
  include Logger::Severity
end
class Concurrent::AbstractExecutorService < Concurrent::Synchronization::LockableObject
  def auto_terminate=(value); end
  def auto_terminate?; end
  def fallback_policy; end
  def handle_fallback(*args); end
  def initialize(*args, &block); end
  def kill; end
  def ns_auto_terminate=(value); end
  def ns_auto_terminate?; end
  def ns_execute(*args, &task); end
  def ns_kill_execution; end
  def ns_shutdown_execution; end
  def running?; end
  def shutdown; end
  def shutdown?; end
  def shuttingdown?; end
  def terminate_at_exit; end
  def wait_for_termination(timeout = nil); end
  include Concurrent::ExecutorService
end
module Concurrent::SerialExecutorService
  def serialized?; end
  include Concurrent::ExecutorService
end
class Concurrent::ImmediateExecutor < Concurrent::AbstractExecutorService
  def <<(task); end
  def initialize; end
  def kill; end
  def post(*args, &task); end
  def running?; end
  def shutdown; end
  def shutdown?; end
  def shuttingdown?; end
  def wait_for_termination(timeout = nil); end
  include Concurrent::SerialExecutorService
end
class Concurrent::Delay < Concurrent::Synchronization::LockableObject
  def execute_task_once; end
  def initialize(opts = nil, &block); end
  def ns_initialize(opts, &block); end
  def reconfigure(&block); end
  def value!(timeout = nil); end
  def value(timeout = nil); end
  def wait(timeout = nil); end
  include Concurrent::Concern::Obligation
end
class Concurrent::ConcurrentUpdateError < ThreadError
end
module Concurrent::AtomicDirectUpdate
  def try_update!; end
  def try_update; end
  def update; end
end
module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
  def compare_and_swap(old_value, new_value); end
end
class Concurrent::MutexAtomicReference < Concurrent::Synchronization::LockableObject
  def _compare_and_set(old_value, new_value); end
  def get; end
  def get_and_set(new_value); end
  def initialize(value = nil); end
  def ns_initialize(value); end
  def set(new_value); end
  def swap(new_value); end
  def value; end
  def value=(new_value); end
  include Concurrent::AtomicDirectUpdate
  include Concurrent::AtomicNumericCompareAndSetWrapper
end
class Concurrent::AtomicReference < Concurrent::MutexAtomicReference
  def inspect; end
  def to_s; end
end
class Concurrent::Utility::ProcessorCounter
  def compute_physical_processor_count; end
  def compute_processor_count; end
  def initialize; end
  def physical_processor_count; end
  def processor_count; end
end
class Concurrent::MutexAtomicBoolean < Concurrent::Synchronization::LockableObject
  def false?; end
  def initialize(initial = nil); end
  def make_false; end
  def make_true; end
  def ns_initialize(initial); end
  def ns_make_value(value); end
  def true?; end
  def value; end
  def value=(value); end
end
class Concurrent::AtomicBoolean < Concurrent::MutexAtomicBoolean
  def inspect; end
  def to_s; end
end
module Concurrent::Utility::NativeInteger
  def ensure_integer(value); end
  def ensure_integer_and_bounds(value); end
  def ensure_lower_bound(value); end
  def ensure_positive(value); end
  def ensure_positive_and_no_zero(value); end
  def ensure_upper_bound(value); end
  extend Concurrent::Utility::NativeInteger
end
class Concurrent::MutexAtomicFixnum < Concurrent::Synchronization::LockableObject
  def compare_and_set(expect, update); end
  def decrement(delta = nil); end
  def down(delta = nil); end
  def increment(delta = nil); end
  def initialize(initial = nil); end
  def ns_initialize(initial); end
  def ns_set(value); end
  def up(delta = nil); end
  def update; end
  def value; end
  def value=(value); end
end
class Concurrent::AtomicFixnum < Concurrent::MutexAtomicFixnum
  def inspect; end
  def to_s; end
end
class Concurrent::CyclicBarrier < Concurrent::Synchronization::LockableObject
  def broken?; end
  def initialize(parties, &block); end
  def ns_generation_done(generation, status, continue = nil); end
  def ns_initialize(parties, &block); end
  def ns_next_generation; end
  def number_waiting; end
  def parties; end
  def reset; end
  def wait(timeout = nil); end
end
class Concurrent::CyclicBarrier::Generation < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def status; end
  def status=(_); end
end
class Concurrent::MutexCountDownLatch < Concurrent::Synchronization::LockableObject
  def count; end
  def count_down; end
  def initialize(count = nil); end
  def ns_initialize(count); end
  def wait(timeout = nil); end
end
class Concurrent::CountDownLatch < Concurrent::MutexCountDownLatch
end
class Concurrent::ReadWriteLock < Concurrent::Synchronization::Object
  def acquire_read_lock; end
  def acquire_write_lock; end
  def has_waiters?; end
  def initialize; end
  def max_readers?(c = nil); end
  def max_writers?(c = nil); end
  def release_read_lock; end
  def release_write_lock; end
  def running_readers(c = nil); end
  def running_readers?(c = nil); end
  def running_writer?(c = nil); end
  def self.new(*args, &block); end
  def waiting_writer?(c = nil); end
  def waiting_writers(c = nil); end
  def with_read_lock; end
  def with_write_lock; end
  def write_locked?; end
end
class Concurrent::AbstractThreadLocalVar
  def allocate_storage; end
  def bind(value, &block); end
  def default; end
  def initialize(default = nil, &default_block); end
  def value; end
  def value=(value); end
end
class Concurrent::RubyThreadLocalVar < Concurrent::AbstractThreadLocalVar
  def allocate_storage; end
  def default_for(thread); end
  def get_threadlocal_array(thread = nil); end
  def self.thread_finalizer(array); end
  def self.threadlocal_finalizer(index); end
  def set_threadlocal_array(array, thread = nil); end
  def value; end
  def value=(value); end
  def value_for(thread); end
end
class Concurrent::ThreadLocalVar < Concurrent::RubyThreadLocalVar
end
class Concurrent::ReentrantReadWriteLock < Concurrent::Synchronization::Object
  def acquire_read_lock; end
  def acquire_write_lock; end
  def initialize; end
  def max_readers?(c = nil); end
  def max_writers?(c = nil); end
  def release_read_lock; end
  def release_write_lock; end
  def running_readers(c = nil); end
  def running_readers?(c = nil); end
  def running_writer?(c = nil); end
  def self.new(*args, &block); end
  def try_read_lock; end
  def try_write_lock; end
  def waiting_or_running_writer?(c = nil); end
  def waiting_writers(c = nil); end
  def with_read_lock; end
  def with_write_lock; end
end
class Concurrent::MutexSemaphore < Concurrent::Synchronization::LockableObject
  def acquire(permits = nil); end
  def available_permits; end
  def drain_permits; end
  def initialize(count); end
  def ns_initialize(count); end
  def reduce_permits(reduction); end
  def release(permits = nil); end
  def try_acquire(permits = nil, timeout = nil); end
  def try_acquire_now(permits); end
  def try_acquire_timed(permits, timeout); end
end
class Concurrent::Semaphore < Concurrent::MutexSemaphore
end
class Concurrent::RubyExecutorService < Concurrent::AbstractExecutorService
  def initialize(*args, &block); end
  def kill; end
  def ns_running?; end
  def ns_shutdown?; end
  def ns_shutdown_execution; end
  def ns_shuttingdown?; end
  def post(*args, &task); end
  def shutdown; end
  def stop_event; end
  def stopped_event; end
  def wait_for_termination(timeout = nil); end
end
class Concurrent::RubyThreadPoolExecutor < Concurrent::RubyExecutorService
  def can_overflow?; end
  def completed_task_count; end
  def idletime; end
  def initialize(opts = nil); end
  def largest_length; end
  def length; end
  def max_length; end
  def max_queue; end
  def min_length; end
  def ns_add_busy_worker; end
  def ns_assign_worker(*args, &task); end
  def ns_enqueue(*args, &task); end
  def ns_execute(*args, &task); end
  def ns_initialize(opts); end
  def ns_kill_execution; end
  def ns_limited_queue?; end
  def ns_prune_pool; end
  def ns_ready_worker(worker, success = nil); end
  def ns_remove_busy_worker(worker); end
  def ns_reset_if_forked; end
  def ns_shutdown_execution; end
  def ns_worker_died(worker); end
  def ns_worker_not_old_enough(worker); end
  def queue_length; end
  def ready_worker(worker); end
  def remaining_capacity; end
  def remove_busy_worker(worker); end
  def scheduled_task_count; end
  def worker_died(worker); end
  def worker_not_old_enough(worker); end
  def worker_task_completed; end
end
class Concurrent::RubyThreadPoolExecutor::Worker
  def <<(message); end
  def create_worker(queue, pool, idletime); end
  def initialize(pool); end
  def kill; end
  def run_task(pool, task, args); end
  def stop; end
  include Concurrent::Concern::Logging
end
class Concurrent::ThreadPoolExecutor < Concurrent::RubyThreadPoolExecutor
end
class Concurrent::CachedThreadPool < Concurrent::ThreadPoolExecutor
  def initialize(opts = nil); end
  def ns_initialize(opts); end
end
class Concurrent::FixedThreadPool < Concurrent::ThreadPoolExecutor
  def initialize(num_threads, opts = nil); end
end
class Concurrent::SimpleExecutorService < Concurrent::RubyExecutorService
  def <<(task); end
  def kill; end
  def ns_initialize; end
  def post(*args, &task); end
  def running?; end
  def self.<<(task); end
  def self.post(*args); end
  def shutdown; end
  def shutdown?; end
  def shuttingdown?; end
  def wait_for_termination(timeout = nil); end
end
class Concurrent::IndirectImmediateExecutor < Concurrent::ImmediateExecutor
  def initialize; end
  def post(*args, &task); end
end
class Concurrent::RubySingleThreadExecutor < Concurrent::RubyThreadPoolExecutor
  def initialize(opts = nil); end
end
class Concurrent::SafeTaskExecutor < Concurrent::Synchronization::LockableObject
  def execute(*args); end
  def initialize(task, opts = nil); end
end
class Concurrent::SerializedExecution < Concurrent::Synchronization::LockableObject
  def call_job(job); end
  def initialize; end
  def ns_initialize; end
  def post(executor, *args, &task); end
  def posts(posts); end
  def work(job); end
  include Concurrent::Concern::Logging
end
class Concurrent::SerializedExecution::Job < Struct
  def args; end
  def args=(_); end
  def block; end
  def block=(_); end
  def call; end
  def executor; end
  def executor=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Concurrent::SerializedExecutionDelegator < SimpleDelegator
  def initialize(executor); end
  def post(*args, &task); end
  include Concurrent::SerialExecutorService
end
class Concurrent::SingleThreadExecutor < Concurrent::RubySingleThreadExecutor
end
module Concurrent::Collection
end
class Concurrent::Collection::CopyOnWriteObserverSet < Concurrent::Synchronization::LockableObject
  def add_observer(observer = nil, func = nil, &block); end
  def clear_observers_and_return_old; end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def initialize; end
  def notify_and_delete_observers(*args, &block); end
  def notify_observers(*args, &block); end
  def notify_to(observers, *args); end
  def ns_initialize; end
  def observers; end
  def observers=(new_set); end
end
class Concurrent::Collection::CopyOnNotifyObserverSet < Concurrent::Synchronization::LockableObject
  def add_observer(observer = nil, func = nil, &block); end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def duplicate_and_clear_observers; end
  def duplicate_observers; end
  def initialize; end
  def notify_and_delete_observers(*args, &block); end
  def notify_observers(*args, &block); end
  def notify_to(observers, *args); end
  def ns_initialize; end
end
module Concurrent::Concern::Observable
  def add_observer(observer = nil, func = nil, &block); end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def observers; end
  def observers=(arg0); end
  def with_observer(observer = nil, func = nil, &block); end
end
class Concurrent::IVar < Concurrent::Synchronization::LockableObject
  def add_observer(observer = nil, func = nil, &block); end
  def check_for_block_or_value!(block_given, value); end
  def complete(success, value, reason); end
  def complete_without_notification(success, value, reason); end
  def fail(reason = nil); end
  def initialize(value = nil, opts = nil, &block); end
  def notify_observers(value, reason); end
  def ns_complete_without_notification(success, value, reason); end
  def ns_initialize(value, opts); end
  def safe_execute(task, args = nil); end
  def set(value = nil); end
  def try_set(value = nil, &block); end
  include Concurrent::Concern::Obligation
  include Concurrent::Concern::Observable
end
module Concurrent::Options
  def self.executor(executor_identifier); end
  def self.executor_from_options(opts = nil); end
end
class Concurrent::ScheduledTask < Concurrent::IVar
  def <=>(other); end
  def cancel; end
  def cancelled?; end
  def execute; end
  def executor; end
  def fail(reason = nil); end
  def initial_delay; end
  def initialize(delay, opts = nil, &task); end
  def ns_reschedule(delay); end
  def ns_schedule(delay); end
  def process_task; end
  def processing?; end
  def reschedule(delay); end
  def reset; end
  def schedule_time; end
  def self.execute(delay, opts = nil, &task); end
  def set(value = nil); end
  def try_set(value = nil, &block); end
  include Comparable
end
class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end
  def clear; end
  def delete(item); end
  def deq; end
  def empty?; end
  def enq(item); end
  def has_priority?(item); end
  def include?(item); end
  def initialize(opts = nil); end
  def length; end
  def ordered?(x, y); end
  def peek; end
  def pop; end
  def push(item); end
  def self.from_list(list, opts = nil); end
  def shift; end
  def sink(k); end
  def size; end
  def swap(x, y); end
  def swim(k); end
end
class Concurrent::Collection::NonConcurrentPriorityQueue < Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end
  def deq; end
  def enq(item); end
  def has_priority?(item); end
  def shift; end
  def size; end
end
class Concurrent::TimerSet < Concurrent::RubyExecutorService
  def <<(task); end
  def initialize(opts = nil); end
  def kill; end
  def ns_initialize(opts); end
  def ns_post_task(task); end
  def ns_reset_if_forked; end
  def ns_shutdown_execution; end
  def post(delay, *args, &task); end
  def post_task(task); end
  def process_tasks; end
  def remove_task(task); end
end
class Concurrent::Agent < Concurrent::Synchronization::LockableObject
  def <<(action); end
  def await; end
  def await_for!(timeout); end
  def await_for(timeout); end
  def deref; end
  def enqueue_action_job(action, args, executor); end
  def enqueue_await_job(latch); end
  def error; end
  def error_mode; end
  def execute_next_job; end
  def failed?; end
  def handle_error(error); end
  def initialize(initial, opts = nil); end
  def ns_enqueue_job(job, index = nil); end
  def ns_find_last_job_for_thread; end
  def ns_initialize(initial, opts); end
  def ns_post_next_job; end
  def ns_validate(value); end
  def post(*args, &action); end
  def reason; end
  def restart(new_value, opts = nil); end
  def self.await(*agents); end
  def self.await_for!(timeout, *agents); end
  def self.await_for(timeout, *agents); end
  def send!(*args, &action); end
  def send(*args, &action); end
  def send_off!(*args, &action); end
  def send_off(*args, &action); end
  def send_via!(executor, *args, &action); end
  def send_via(executor, *args, &action); end
  def stopped?; end
  def value; end
  def wait(timeout = nil); end
  include Concurrent::Concern::Observable
end
class Concurrent::Agent::Job < Struct
  def action; end
  def action=(_); end
  def args; end
  def args=(_); end
  def caller; end
  def caller=(_); end
  def executor; end
  def executor=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Concurrent::Agent::Error < StandardError
  def initialize(message = nil); end
end
class Concurrent::Agent::ValidationError < Concurrent::Agent::Error
  def initialize(message = nil); end
end
class Concurrent::Atom < Concurrent::Synchronization::Object
  def compare_and_set(old_value, new_value); end
  def compare_and_set_value(expected, value); end
  def deref; end
  def initialize(value, opts = nil); end
  def initialize_volatile_with_cas; end
  def reset(new_value); end
  def self.new(*args, &block); end
  def swap(*args); end
  def swap_value(value); end
  def update_value(&block); end
  def valid?(new_value); end
  def value; end
  def value=(value); end
  include Concurrent::Concern::Observable
end
module Concurrent::ThreadSafe
end
module Concurrent::ThreadSafe::Util
end
class Concurrent::Array < Array
end
class Concurrent::Hash < Hash
end
class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end
  def []=(key, value); end
  def _get(key); end
  def _set(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def dupped_backend; end
  def each_pair; end
  def get_and_set(key, value); end
  def get_or_default(key, default_value); end
  def initialize(options = nil); end
  def initialize_copy(other); end
  def key?(key); end
  def merge_pair(key, value); end
  def pair?(key, expected_value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
  def size; end
  def store_computed_value(key, new_value); end
end
class Concurrent::Collection::MriMapBackend < Concurrent::Collection::NonConcurrentMapBackend
  def []=(key, value); end
  def clear; end
  def compute(key); end
  def compute_if_absent(key); end
  def compute_if_present(key); end
  def delete(key); end
  def delete_pair(key, value); end
  def get_and_set(key, value); end
  def initialize(options = nil); end
  def merge_pair(key, value); end
  def replace_if_exists(key, new_value); end
  def replace_pair(key, old_value, new_value); end
end
class Concurrent::Map < Concurrent::Collection::MriMapBackend
  def [](key); end
  def each; end
  def each_key; end
  def each_value; end
  def empty?; end
  def fetch(key, default_value = nil); end
  def fetch_or_store(key, default_value = nil); end
  def get(key); end
  def initialize(options = nil, &block); end
  def initialize_copy(other); end
  def inspect; end
  def key(value); end
  def keys; end
  def marshal_dump; end
  def marshal_load(hash); end
  def populate_from(hash); end
  def put(key, value); end
  def put_if_absent(key, value); end
  def raise_fetch_no_key; end
  def validate_options_hash!(options); end
  def value?(value); end
  def values; end
end
class Concurrent::Tuple
  def cas(i, old_value, new_value); end
  def compare_and_set(i, old_value, new_value); end
  def each; end
  def get(i); end
  def initialize(size); end
  def set(i, value); end
  def size; end
  def volatile_get(i); end
  def volatile_set(i, value); end
  include Enumerable
end
module Concurrent::Async
  def async; end
  def await; end
  def call; end
  def cast; end
  def init_synchronization; end
  def self.included(base); end
  def self.validate_argc(obj, method, *args); end
end
module Concurrent::Async::ClassMethods
  def new(*args, &block); end
end
class Concurrent::Async::AsyncDelegator < Concurrent::Synchronization::LockableObject
  def initialize(delegate); end
  def method_missing(method, *args, &block); end
  def perform; end
end
class Concurrent::Async::AwaitDelegator
  def initialize(delegate); end
  def method_missing(method, *args, &block); end
end
class Concurrent::Future < Concurrent::IVar
  def cancel; end
  def cancelled?; end
  def execute; end
  def initialize(opts = nil, &block); end
  def ns_initialize(value, opts); end
  def self.execute(opts = nil, &block); end
  def set(value = nil, &block); end
  def wait_or_cancel(timeout); end
end
class Concurrent::DependencyCounter
  def initialize(count, &block); end
  def update(time, value, reason); end
end
class Concurrent::Maybe < Concurrent::Synchronization::Object
  def <=>(other); end
  def fulfilled?; end
  def initialize(just, nothing); end
  def just; end
  def just?; end
  def nothing; end
  def nothing?; end
  def or(other); end
  def reason; end
  def rejected?; end
  def self.from(*args); end
  def self.just(value); end
  def self.new(*args, &block); end
  def self.nothing(error = nil); end
  def value; end
  include Comparable
end
class Concurrent::AbstractExchanger < Concurrent::Synchronization::Object
  def do_exchange(value, timeout); end
  def exchange!(value, timeout = nil); end
  def exchange(value, timeout = nil); end
  def initialize; end
  def try_exchange(value, timeout = nil); end
end
class Concurrent::RubyExchanger < Concurrent::AbstractExchanger
  def compare_and_set_slot(expected, value); end
  def do_exchange(value, timeout); end
  def initialize; end
  def initialize_volatile_with_cas; end
  def self.new(*args, &block); end
  def slot; end
  def slot=(value); end
  def swap_slot(value); end
  def update_slot(&block); end
end
class Concurrent::RubyExchanger::Node < Concurrent::Synchronization::Object
  def compare_and_set_value(expected, value); end
  def initialize(item); end
  def initialize_volatile_with_cas; end
  def item; end
  def latch; end
  def self.new(*args, &block); end
  def swap_value(value); end
  def update_value(&block); end
  def value; end
  def value=(value); end
end
class Concurrent::Exchanger < Concurrent::RubyExchanger
end
module Concurrent::Synchronization::AbstractStruct
  def initialize(*values); end
  def length; end
  def members; end
  def ns_each; end
  def ns_each_pair; end
  def ns_equality(other); end
  def ns_get(member); end
  def ns_inspect; end
  def ns_merge(other, &block); end
  def ns_select; end
  def ns_to_h; end
  def ns_values; end
  def ns_values_at(indexes); end
  def pr_underscore(clazz); end
  def self.define_struct_class(parent, base, name, members, &block); end
  def size; end
end
module Concurrent::ImmutableStruct
  def ==(other); end
  def [](member); end
  def each(&block); end
  def each_pair(&block); end
  def inspect; end
  def merge(other, &block); end
  def select(&block); end
  def self.included(base); end
  def self.new(*args, &block); end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*indexes); end
  include Concurrent::Synchronization::AbstractStruct
end
module Concurrent::MutableStruct
  def ==(other); end
  def [](member); end
  def []=(member, value); end
  def each(&block); end
  def each_pair(&block); end
  def inspect; end
  def merge(other, &block); end
  def select(&block); end
  def self.new(*args, &block); end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*indexes); end
  include Concurrent::Synchronization::AbstractStruct
end
class Concurrent::MVar < Concurrent::Synchronization::Object
  def borrow(timeout = nil); end
  def empty?; end
  def full?; end
  def initialize(value = nil, opts = nil); end
  def modify!; end
  def modify(timeout = nil); end
  def put(value, timeout = nil); end
  def self.new(*args, &block); end
  def set!(value); end
  def synchronize(&block); end
  def take(timeout = nil); end
  def try_put!(value); end
  def try_take!; end
  def unlocked_empty?; end
  def unlocked_full?; end
  def wait_for_empty(timeout); end
  def wait_for_full(timeout); end
  def wait_while(condition, timeout); end
  include Concurrent::Concern::Dereferenceable
end
class Concurrent::PromiseExecutionError < StandardError
end
class Concurrent::Promise < Concurrent::IVar
  def catch(&block); end
  def complete(success, value, reason); end
  def execute; end
  def fail(reason = nil); end
  def flat_map(&block); end
  def initialize(opts = nil, &block); end
  def notify_child(child); end
  def ns_initialize(value, opts); end
  def on_error(&block); end
  def on_fulfill(result); end
  def on_reject(reason); end
  def on_success(&block); end
  def realize(task); end
  def rescue(&block); end
  def root?; end
  def self.aggregate(method, *promises); end
  def self.all?(*promises); end
  def self.any?(*promises); end
  def self.execute(opts = nil, &block); end
  def self.fulfill(value, opts = nil); end
  def self.reject(reason, opts = nil); end
  def self.zip(*promises); end
  def set(value = nil, &block); end
  def set_pending; end
  def set_state!(success, value, reason); end
  def synchronized_set_state!(success, value, reason); end
  def then(rescuer = nil, executor = nil, &block); end
  def zip(*others); end
end
module Concurrent::SettableStruct
  def ==(other); end
  def [](member); end
  def []=(member, value); end
  def each(&block); end
  def each_pair(&block); end
  def inspect; end
  def merge(other, &block); end
  def select(&block); end
  def self.new(*args, &block); end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*indexes); end
  include Concurrent::Synchronization::AbstractStruct
end
class Concurrent::TimerTask < Concurrent::RubyExecutorService
  def <<(task); end
  def execute; end
  def execute_task(completion); end
  def execution_interval; end
  def execution_interval=(value); end
  def initialize(opts = nil, &task); end
  def ns_initialize(opts, &task); end
  def ns_kill_execution; end
  def ns_shutdown_execution; end
  def post(*args, &task); end
  def running?; end
  def schedule_next_task(interval = nil); end
  def self.execute(opts = nil, &task); end
  def timeout_interval; end
  def timeout_interval=(value); end
  def timeout_task(completion); end
  include Concurrent::Concern::Dereferenceable
  include Concurrent::Concern::Observable
end
class Concurrent::TVar < Concurrent::Synchronization::Object
  def initialize(value); end
  def self.new(*args, &block); end
  def unsafe_increment_version; end
  def unsafe_lock; end
  def unsafe_value; end
  def unsafe_value=(value); end
  def unsafe_version; end
  def value; end
  def value=(value); end
end
class Concurrent::Transaction
  def abort; end
  def commit; end
  def initialize; end
  def read(tvar); end
  def self.current; end
  def self.current=(transaction); end
  def unlock; end
  def valid?; end
  def write(tvar, value); end
end
class Concurrent::Transaction::ReadLogEntry < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def tvar; end
  def tvar=(_); end
  def version; end
  def version=(_); end
end
class Concurrent::Transaction::AbortError < StandardError
end
class Concurrent::Transaction::LeaveError < StandardError
end
class Concurrent::SynchronizedDelegator < SimpleDelegator
  def initialize(obj); end
  def method_missing(method, *args, &block); end
  def setup; end
  def teardown; end
end
